import { inject, injectable } from 'inversify';
import { DbConnection } from '../services/db-connection.class';
import { hash } from 'bcrypt';
import { TableName } from '../utils/db-orchestrator';
import * as randomatic from 'randomatic';

export enum UserRole {
  EMPLOYEE = 1,
  ADMIN = 2,
}

export interface IUserCreateNoPassword {
  userId?: number;
  role: UserRole;
  email: string;
  fullName: string;
}

export interface IUserCreate extends IUserCreateNoPassword {
  password: string;
}

export interface IUser extends IUserCreate {
  userId: number;
}

export interface IUserWithPassword extends IUser, IUserCreateNoPassword {
  userId: number;
}

export interface IDBUser extends IUser {
  passwordHash: string;
}

@injectable()
export class UsersModel {
  private _dbConnection: DbConnection;

  public get table() {
    return this._dbConnection.knex(TableName.USERS);
  }

  constructor(@inject(DbConnection) dbConnection: DbConnection) {
    this._dbConnection = dbConnection;
  }

  create(
    user: Readonly<IUserCreate>,
    returning: ReadonlyArray<keyof IUserCreate>,
  ): Promise<IUser>;
  create(
    user: Readonly<IUserCreate>,
  ): Promise<void>;
  create(
    user: Readonly<IUserCreateNoPassword>,
    returning: ReadonlyArray<keyof IUserWithPassword>,
  ): Promise<IUserWithPassword>;
  create(
    user: Readonly<IUserCreateNoPassword>,
  ): Promise<void>;
  async create(
    user: Readonly<IUserCreateNoPassword & IUserCreate>,
    returning?: ReadonlyArray<keyof (IUserCreateNoPassword & IUserCreate)>,
  ): Promise<IUser | void> {
    const { password = randomatic('aA0!', 72), ...userSeed } = user as (IUserWithPassword & IDBUser);
    userSeed.passwordHash = await hash(password, 13);
    if (!user.password) {
      if (!returning || !returning.includes('password')) {
        throw new TypeError('Password is being generated by ignored by caller!');
      }
      const newUser = await this.table
        .insert(userSeed, returning as string[]) as IUserWithPassword;
      newUser.password = password;
      return newUser;
    }
    return await this.table
      .insert(userSeed, returning as string[]) as IUser;
  }
}
