"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bcrypt_1 = require("bcrypt");
const inversify_1 = require("inversify");
const randomatic = require("randomatic");
const db_connection_class_1 = require("../services/db-connection.class");
const error_service_1 = require("../services/error.service");
const db_orchestrator_1 = require("../utils/db-orchestrator");
var UserRole;
(function (UserRole) {
    UserRole[UserRole["EMPLOYEE"] = 1] = "EMPLOYEE";
    UserRole[UserRole["ADMIN"] = 2] = "ADMIN";
})(UserRole = exports.UserRole || (exports.UserRole = {}));
function getUserRoleLimits() {
    return [UserRole.EMPLOYEE, UserRole.ADMIN];
}
exports.getUserRoleLimits = getUserRoleLimits;
exports.maxBcryptStringToHashLength = 72;
exports.bcryptOptimalHashCycles = 13;
let UsersModel = class UsersModel {
    constructor(dbConnection) {
        this._dbConnection = dbConnection;
    }
    get table() {
        return this._dbConnection.knex(db_orchestrator_1.TableName.USERS);
    }
    async getAssertedUser(userCredentials, returning = getAllSafeUserPropertyNames()) {
        if (!userCredentials.password) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_NO);
        }
        const select = returning.slice();
        const passwordHashRequested = returning.includes('passwordHash');
        if (!passwordHashRequested) {
            select.push('passwordHash');
        }
        const user = await this.getOne({ email: userCredentials.email }, select);
        if (!user) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_BAD);
        }
        if (!await bcrypt_1.compare(userCredentials.password, user.passwordHash)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_BAD);
        }
        if (!passwordHashRequested) {
            delete user.passwordHash;
        }
        return user;
    }
    async getOne(emailOrUserId, returning = getAllSafeUserPropertyNames()) {
        if (!isValidUserUniqueIdentifier(emailOrUserId)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_AND_ID, 'Both email and user id present. Use only one of them.');
        }
        const users = await this.table.where(emailOrUserId)
            .select(returning);
        if (users.length === 0) {
            return null;
        }
        return users[0];
    }
    async deleteOne(emailOrUserId) {
        if (!isValidUserUniqueIdentifier(emailOrUserId)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_AND_ID, 'Both email and user id present. Use only one of them.');
        }
        return this.table.where(emailOrUserId).delete();
    }
    async create(user, returning) {
        const { password = getRandomPassword(), ...userSeed } = user;
        userSeed.passwordHash = await bcrypt_1.hash(password, exports.bcryptOptimalHashCycles);
        if (!user.password) {
            if (!returning || !returning.includes('password')) {
                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_SAVE_NO, 'Password is being generated by ignored by caller!');
            }
            const newUser = await this.table
                .insert(userSeed, returning);
            newUser.password = password;
            return newUser;
        }
        return await this.table
            .insert(userSeed, returning);
    }
};
UsersModel = tslib_1.__decorate([
    inversify_1.injectable(),
    tslib_1.__param(0, inversify_1.inject(db_connection_class_1.DbConnection)),
    tslib_1.__metadata("design:paramtypes", [db_connection_class_1.DbConnection])
], UsersModel);
exports.UsersModel = UsersModel;
function isValidUserUniqueIdentifier(emailOrUserId) {
    return Object.keys(emailOrUserId).length === 1 && ('email' in emailOrUserId
        || 'userId' in emailOrUserId);
}
exports.isValidUserUniqueIdentifier = isValidUserUniqueIdentifier;
function getRandomPassword() {
    return randomatic('aA0!', exports.maxBcryptStringToHashLength);
}
exports.getRandomPassword = getRandomPassword;
function getAllSafeUserPropertyNames() {
    return ['userId', 'email', 'role', 'fullName'];
}
exports.getAllSafeUserPropertyNames = getAllSafeUserPropertyNames;
//# sourceMappingURL=users.model.js.map