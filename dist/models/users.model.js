"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bcrypt_1 = require("bcrypt");
const inversify_1 = require("inversify");
const db_connection_class_1 = require("../services/db-connection.class");
const error_service_1 = require("../services/error.service");
const db_orchestrator_1 = require("../utils/db-orchestrator");
const users_1 = require("../utils/models/users");
let UsersModel = class UsersModel {
    constructor(dbConnection) {
        this._dbConnection = dbConnection;
        switch (this._dbConnection.config.client) {
            case 'pg':
                this._handleError = err => {
                    switch (err.code) {
                        case '23505':
                            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_DUPLICATE);
                        default:
                            throw err;
                    }
                };
                break;
            default:
                throw new TypeError(`Cannot create handler for database errors for ${this._dbConnection.config.client}`);
        }
    }
    get table() {
        return this._dbConnection.knex(db_orchestrator_1.TableName.USERS);
    }
    async getAssertedUser(userCredentials, returning = users_1.getAllSafeUserPropertyNames()) {
        if (!userCredentials.password) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_NO);
        }
        const select = returning.slice();
        const passwordHashRequested = returning.includes('passwordHash');
        if (!passwordHashRequested) {
            select.push('passwordHash');
        }
        const user = await this.getOne({ email: userCredentials.email }, select);
        if (!user || !await bcrypt_1.compare(userCredentials.password, user.passwordHash)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_CREDENTIALS_BAD);
        }
        if (!passwordHashRequested) {
            delete user.passwordHash;
        }
        return user;
    }
    async getOne(emailOrUserId, returning = users_1.getAllSafeUserPropertyNames()) {
        if (!users_1.isValidUserUniqueIdentifier(emailOrUserId)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_AND_ID, 'Both email and user id present. Use only one of them.');
        }
        const users = await this.table.where(emailOrUserId)
            .select(returning);
        if (users.length === 0) {
            return null;
        }
        return users[0];
    }
    async deleteOne(emailOrUserId) {
        if (!users_1.isValidUserUniqueIdentifier(emailOrUserId)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_AND_ID, 'Both email and user id present. Use only one of them.');
        }
        return this.table.where(emailOrUserId).delete();
    }
    async createOne(user, returning) {
        const { password = users_1.getRandomPassword(), ...userSeed } = user;
        userSeed.passwordHash = await bcrypt_1.hash(password, users_1.bcryptOptimalHashCycles);
        const passwordIndex = returning ? returning.indexOf('password') : -1;
        if (!user.password) {
            if (passwordIndex < 0) {
                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_SAVE_NO, 'Password is being generated by ignored by caller!');
            }
            const select = returning.slice();
            select.splice(passwordIndex, 1);
            const newUser = (await this.table
                .insert(userSeed, select).catch(this._handleError))[0];
            newUser.password = password;
            return newUser;
        }
        else {
            if (passwordIndex >= 0) {
                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_PROVIDED, 'Password is not generated but requested!');
            }
        }
        return this.table
            .insert(userSeed, returning)
            .catch(this._handleError)
            .then(users => returning && returning.length !== 0 ? users[0] : {});
    }
};
UsersModel = tslib_1.__decorate([
    inversify_1.injectable(),
    tslib_1.__param(0, inversify_1.inject(db_connection_class_1.DbConnection)),
    tslib_1.__metadata("design:paramtypes", [db_connection_class_1.DbConnection])
], UsersModel);
exports.UsersModel = UsersModel;
//# sourceMappingURL=users.model.js.map