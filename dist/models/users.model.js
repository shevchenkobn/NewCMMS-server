"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bcrypt_1 = require("bcrypt");
const inversify_1 = require("inversify");
const pg_error_enum_1 = require("pg-error-enum");
const db_connection_class_1 = require("../services/db-connection.class");
const error_service_1 = require("../services/error.service");
const db_orchestrator_1 = require("../utils/db-orchestrator");
const model_1 = require("../utils/model");
const users_1 = require("../utils/models/users");
let UsersModel = class UsersModel {
    constructor(dbConnection) {
        this._dbConnection = dbConnection;
        switch (this._dbConnection.config.client) {
            case 'pg':
                this._handleError = err => {
                    switch (err.code) {
                        case pg_error_enum_1.PostgresError.UNIQUE_VIOLATION:
                            const detailLower = err.detail.toLowerCase();
                            if (detailLower.includes('email')) {
                                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_DUPLICATE);
                            }
                        default:
                            throw err;
                    }
                };
                break;
            default:
                throw new TypeError(`Cannot create handler for database errors for ${this._dbConnection.config.client}`);
        }
    }
    get table() {
        return this._dbConnection.knex(db_orchestrator_1.TableName.USERS);
    }
    async getAssertedUser(userCredentials, returning = users_1.getAllSafeUserPropertyNames()) {
        if (!userCredentials.password) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_NO);
        }
        const select = returning.slice();
        const passwordHashRequested = returning.includes('passwordHash');
        if (!passwordHashRequested) {
            select.push('passwordHash');
        }
        const user = await this.getOne({ email: userCredentials.email }, select);
        if (!user || !await bcrypt_1.compare(userCredentials.password, user.passwordHash)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_CREDENTIALS_BAD);
        }
        if (!passwordHashRequested) {
            delete user.passwordHash;
        }
        return user;
    }
    async getOne(emailOrUserId, select = users_1.getAllSafeUserPropertyNames()) {
        if (!users_1.isValidUserUniqueIdentifier(emailOrUserId)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_AND_ID, 'Both email and username id present. Use only one of them.');
        }
        const users = await this.table.where(emailOrUserId)
            .select(select);
        if (users.length === 0) {
            return null;
        }
        return users[0];
    }
    getList(params) {
        const query = this.table;
        if (params.userIds && params.userIds.length > 0) {
            query.whereIn(db_orchestrator_1.getIdColumn(db_orchestrator_1.TableName.USERS), params.userIds.slice());
        }
        if (params.comparatorFilters && params.comparatorFilters.length > 0) {
            for (const filter of params.comparatorFilters) {
                query.where(...filter);
            }
        }
        if (typeof params.offset === 'number') {
            query.offset(params.offset);
        }
        if (typeof params.limit === 'number') {
            query.limit(params.limit);
        }
        if (params.orderBy && params.orderBy.length > 0) {
            model_1.applySortingToQuery(query, params.orderBy);
        }
        return query.select((params.select && params.select.length > 0
            ? params.select.slice()
            : users_1.getAllSafeUserPropertyNames()));
    }
    deleteOne(emailOrUserId, returning) {
        if (!users_1.isValidUserUniqueIdentifier(emailOrUserId)) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_EMAIL_AND_ID, 'Both email and username id present. Use only one of them.');
        }
        return this.table.where(emailOrUserId).delete(returning)
            .then(users => {
            if (!returning || returning.length === 0) {
                return users === 0 ? null : {};
            }
            return users.length === 0 ? null : users[0];
        })
            .catch(this._handleError);
    }
    async createOne(user, returning) {
        const { password = users_1.getRandomPassword(), ...userSeed } = user;
        const passwordIndex = returning ? returning.indexOf('password') : -1;
        if (!user.password) {
            if (passwordIndex < 0) {
                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_SAVE_NO, 'Password is being generated by ignored by caller!');
            }
        }
        else {
            if (passwordIndex >= 0) {
                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_PROVIDED, 'Password is not generated but requested!');
            }
        }
        userSeed.passwordHash = await bcrypt_1.hash(password, users_1.bcryptOptimalHashCycles);
        let select;
        if (returning) {
            select = returning.slice();
            if (passwordIndex >= 0) {
                select.splice(passwordIndex, 1);
            }
        }
        else {
            select = [];
        }
        return this.table
            .insert(userSeed, select)
            .catch(this._handleError)
            .then(users => {
            if (!returning) {
                return {};
            }
            const user = users[0];
            if (passwordIndex >= 0) {
                user.password = password;
            }
            return user;
        });
    }
    async updateOne(userId, update, returning) {
        // tslint:disable-next-line:prefer-const
        let { password, ...userSeed } = update;
        const passwordIndex = returning ? returning.indexOf('password') : -1;
        if (password === '') {
            if (passwordIndex < 0) {
                throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_SAVE_NO);
            }
            password = users_1.getRandomPassword();
        }
        else if (passwordIndex >= 0) {
            throw new error_service_1.LogicError(error_service_1.ErrorCode.USER_PASSWORD_NO);
        }
        if (password) {
            userSeed.passwordHash = await bcrypt_1.hash(password, users_1.bcryptOptimalHashCycles);
        }
        let select;
        if (returning) {
            select = returning.slice();
            if (passwordIndex >= 0) {
                select.splice(passwordIndex, 1);
            }
        }
        else {
            select = [];
        }
        return this.table.where({ userId }).update(userSeed, select)
            .then(users => {
            if (!returning) {
                return users === 0 ? null : {};
            }
            if (users.length === 0) {
                return null;
            }
            const user = users[0];
            if (passwordIndex >= 0) {
                user.password = password;
            }
            return user;
        })
            .catch(this._handleError);
    }
};
UsersModel = tslib_1.__decorate([
    inversify_1.injectable(),
    tslib_1.__param(0, inversify_1.inject(db_connection_class_1.DbConnection)),
    tslib_1.__metadata("design:paramtypes", [db_connection_class_1.DbConnection])
], UsersModel);
exports.UsersModel = UsersModel;
//# sourceMappingURL=users.model.js.map